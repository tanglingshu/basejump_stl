#! /usr/bin/python3
# bsg_adder_wallace_tree_generator.py
# This script generates wallace for reducing addition N operands using 3-2 CSA. And it's more efficient than 4-2 wallace_tree.
# Usage:
# ./bsg_adder_wallace_tree_generator.py N
# where N is the number of operands to add
# And script will generate a .sv file named bsg_adder_wallace_tree_<N>.v to meet the requirements.

import sys
from math import log2, ceil
from queue import Queue

# Basic template to generate carry save adder.

csa_template = '''bsg_adder_carry_save#(
  .width_p({})
) {} (
  .opA_i({})
  ,.opB_i({})
  ,.opC_i({})
  ,.res_o({})
  ,.car_o({})
);
'''

# generate function

def put_csa(width_p:str, opA: str, opB: str, opC: str, name: str, f):
    res_o = "{}_res_o".format(name)
    car_o = "{}_car_o".format(name)
    return (csa_template.format(width_p, name, opA, opB, opC, res_o, car_o).rjust(2), res_o, car_o)

if len(sys.argv) != 2 or not sys.argv[1].isdigit():
    print("Usage: ./bsg_adder_wallace_tree_generator.py <number_of_operand>")
    exit(-1)

N = int(sys.argv[1])
if N == 1 or N == 2:
    print("There is no need to aggregate {} number(s) using wallace tree.".format(N))
    exit(-2)


size_list = {} # record the wire size.
# This function is for truncation and extension with unsigned number.
def matchSize(name: str, output_size: int, left_shift:bool = False):
    if name in size_list:
        size = size_list[name];
        if(size == output_size): return name
        elif (size > output_size): return "{}[width_p{:+}:0]".format(name,output_size-1)
        elif (size < output_size): return "{{{}'b0, {}}}".format(output_size-size, name) if not left_shift else "{{{},{}'b0}}".format(name,output_size-size)
    else:
        print("Error: looking up a non-existed wire: {}".format(name))
        exit(-1)

with open("bsg_adder_wallace_tree_{}.v".format(N),"w") as f:
    puts = lambda x: print(x, file=f)
    puts_list = []
    puts("//This file is automatically generated by python script ./bsg_adder_wallace_tree_generator.py with N = {}. Do not modify.".format(N))
    # generate module header
    puts("module bsg_adder_wallace_tree_{} #(".format(N))
    puts("  parameter integer width_p = \"inv\"")
    puts(")(")

    # I/O ports
    output_size_bias =  ceil(log2(N))
    puts("  input [{}:0][width_p-1:0] ops_i".format(N-1))
    puts("  ,output [{}+width_p:0] resA_o".format(output_size_bias))
    puts("  ,output [{}+width_p:0] resB_o".format(output_size_bias))
    puts(");")
    
    # operand pending
    reduce_queue = Queue()
    for i in range(N):
        reduce_queue.put("ops_i[{}]".format(i))
        size_list["ops_i[{}]".format(i)] = 0
    
    layer_num = 0
    internal_wire_num = 0;
    wire_list = []
    while True:
        csa_num = reduce_queue.qsize() // 3
        csa_width = min(output_size_bias+1, layer_num)
        if csa_num == 0: break;
        for i in range(csa_num):
            (csa_str, csa_sum, csa_carry) = put_csa("width_p{:+}".format(csa_width),matchSize(reduce_queue.get(),csa_width),matchSize(reduce_queue.get(),csa_width),matchSize(reduce_queue.get(),csa_width),"csa_{}_{}".format(layer_num,i),f)
            # record output wire of CSA.
            size_list[csa_sum] = csa_width
            size_list[csa_carry] = csa_width
            puts_list.append(csa_str) # put CSA instantation.
            # generate wire for interconnection
            puts_list.append("wire [width_p{:+}:0] csa_internal_wire_{} = {};".format(csa_width,internal_wire_num,matchSize(csa_sum, csa_width + 1)))
            puts_list.append("wire [width_p{:+}:0] csa_internal_wire_{} = {};".format(csa_width, internal_wire_num+1,matchSize(csa_carry, csa_width + 1, True)))
            wire_list.append("wire [width_p{:+}:0] {};".format(csa_width-1,csa_sum))
            wire_list.append("wire [width_p{:+}:0] {};".format(csa_width-1,csa_carry))
            reduce_queue.put("csa_internal_wire_{}".format(internal_wire_num))
            reduce_queue.put("csa_internal_wire_{}".format(internal_wire_num+1))
            size_list["csa_internal_wire_{}".format(internal_wire_num)] = csa_width + 1
            size_list["csa_internal_wire_{}".format(internal_wire_num+1)] = csa_width + 1
            internal_wire_num += 2
        layer_num += 1

    puts("\n".join(wire_list))
    puts("")
    puts("\n".join(puts_list))
    puts("")
    
    puts("assign resA_o = {};".format(reduce_queue.get()))
    puts("assign resB_o = {};".format(reduce_queue.get()))
    # end of the module
    puts("endmodule")
    puts("")
